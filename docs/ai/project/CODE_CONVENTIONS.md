# Code Conventions

This document is auto-generated by the `generate-standards` command.

Do not edit manually. To influence the generated content, edit the preload templates instead:

- `docs/ai/project/template-convention/common.md` (always loaded first)
- `docs/ai/project/template-convention/javascript.md` (loaded if JS/TS repo)
- `docs/ai/project/template-convention/react.md` (loaded if React is detected)

The generator merges the above templates (when present) and then appends auto-discovered rules from the codebase.

---

## Project-specific conventions (Next.js + Supabase + TypeScript)

### TypeScript

- Enable strict mode (`"strict": true`) and no implicit `any` in `tsconfig.json`.
- Prefer explicit function return types for exported/public APIs.
- Use discriminated unions over enums where ergonomics permit; avoid `any`.
- Name files in `camelCase` or `kebab-case` consistently; React components in `PascalCase.tsx`.

### React / Next.js

- **Server-First Approach for SEO Optimization:**
  - Use Server Components by default; opt into Client Components (`"use client"`) only when interactivity (state, events, browser APIs) is required.
  - Prefer Server Actions for data mutations and form submissions to minimize client-side JavaScript.
  - Fetch data in Server Components whenever possible (co-located with the component) for optimal performance and SEO.
  - Use `generateMetadata` for dynamic page metadata to improve SEO and social sharing.
  - Leverage streaming with Suspense boundaries to improve perceived performance and SEO (avoid blocking the entire page).
- Use App Router (`src/app`) structure; keep route files thin (page.tsx, layout.tsx) and import logic from feature modules.
- Place route handlers in `app/**/route.ts` for APIs/webhooks; use Server Actions in feature modules for mutations.
- Keep components pure; colocate feature-specific components within their feature directories.
- Avoid deep prop drilling; use context sparingly and memoization (`useMemo`, `useCallback`) only when profiling indicates bottlenecks.
- Prefer `next/link` and `next/navigation` hooks; avoid legacy router APIs.

### Styling (Tailwind CSS)

- Use utility-first classes; extract reusable patterns into components, not giant class strings.
- Keep `globals.css` minimal; add component-scoped styles via Tailwind or CSS modules only when necessary.
- Order Tailwind classes logically (layout → box-model → typography → visual → state → responsive).

### Supabase

- Initialize a browser client with `NEXT_PUBLIC_*` keys and a server client with the service role key server-side only.
- Never expose service role key to the client; use Route Handlers/Server Actions for privileged operations.
- Use Row Level Security (RLS) with policies; do not bypass with service role unless strictly needed.
- Store auth state via Supabase helpers; avoid duplicating session state in Redux/Zustand by default.

### Project structure (Feature-Sliced pattern)

```
src/
  app/                # Thin routing layer (page.tsx, layout.tsx only)
  components/         # Shared components used by 2+ features (ui/, shared/)
  features/           # Feature modules (auth/, posts/, dashboard/, etc.)
    <feature>/
      components/     # Feature-specific components
      actions.ts      # Server Actions for this feature
      service.ts      # Data access layer (Supabase calls)
      types.ts        # Feature-specific types
      page.tsx        # Actual page component
  lib/                # Utilities (e.g., supabase clients, helpers, validators)
  styles/             # Tailwind and global styles
```

See `PROJECT_STRUCTURE.md` for detailed Feature-Sliced organization guidelines.

### Testing & Quality

- Lint with ESLint and format with Prettier; CI should block on both.
- Add lightweight component tests for critical UI; prefer integration tests for auth/data flows.
- Avoid `console.log` in committed code; use typed logger where needed.

### Git & Commits

- Conventional Commits (`feat:`, `fix:`, `docs:`, `refactor:`, etc.).
- Keep pull requests focused and small; include screenshots for UI changes.

<!-- GENERATED: CODE_CONVENTIONS:START -->

This document is auto-generated from codebase analysis + brief Q&A. Edit manually as needed.

# Preloaded Templates

## From common.md

```1:62:docs/ai/project/template-convention/common.md
# CODE_CONVENTIONS Common Rules (Template Preload)

> These rules are preloaded by the standards generator before analyzing the codebase. They establish non-negotiable, high-signal conventions. The generator should merge these rules first, then append auto-discovered patterns.

## Principles — The "Why"
- DRY (Don't Repeat Yourself): Avoid duplicating code. Abstract common logic into reusable functions, classes, or modules.
- KISS (Keep It Simple, Stupid): Prefer simple, straightforward solutions over clever or unnecessarily complex ones. Code should be as simple as possible, but no simpler.
- YAGNI (You Ain't Gonna Need It): Do not add functionality or create abstractions until they are actually needed. Avoid premature optimization.

## Naming — Clarity & Descriptiveness
- Prefer meaningful, verbose names over abbreviations.
- Avoid 1–2 character identifiers (except conventional counters like `i`, `j`, `k` in very small loop scopes).
- Be consistent. If you use `getUser` in one place, use `getProduct` in another, not `fetchProduct`.
- Function names should be verbs; variables and classes should be nouns. (e.g., `calculateTotal()`, `const user`, `class Order`).

## Functions / Methods
- Single Responsibility Principle: A function should do one thing and do it well. If you can't describe what a function does in one simple sentence, it's likely doing too much.
- Limit Arguments: Prefer 0-2 arguments per function. If you need more than two, consider passing a single configuration object.
- Avoid Side Effects: Functions should be predictable. They should avoid modifying external state, global variables, or their own input arguments whenever possible. A function `calculateTotal(items)` should return a new value, not modify the original `items` array.

## Control Flow
- Prefer guard clauses (early returns) to reduce nesting depth.
- Handle errors and edge cases first.
- Avoid deep nesting beyond 2–3 levels. Refactor deeply nested logic into smaller, well-named functions.

## Variables & Data Structures
- Minimize Scope: Declare variables in the smallest possible scope (e.g., inside a loop or conditional block if they are only used there).
- Avoid Magic Values: Do not use "magic" strings or numbers directly in code. Define them as named constants to provide context and avoid typos.
  - *Bad:* `if (status === 2) { ... }`
  - *Good:* `const STATUS_APPROVED = 2; if (status === STATUS_APPROVED) { ... }`
- Prefer Immutability:** Do not reassign variables or mutate data structures if it can be avoided. Creating new data structures instead of changing existing ones leads to more predictable code.

## Error Handling
- Throw errors with clear, actionable messages.
- Do not catch errors without meaningful handling (e.g., logging, retrying, or re-throwing a more specific error). Swallowing exceptions silently is a major source of bugs.

## Comments
- Add comments only for complex or non-obvious logic; explain **"why"**, not **"how"**. Well-written code should explain the "how" by itself.
- Place comments above code blocks or use language-specific docstrings.
- Avoid trailing inline comments as they can clutter code.
- Remove Dead Code: Do not leave commented-out code in the codebase. Source control (like Git) is the history.

## Formatting
- Match existing repository formatting tools and styles (e.g., Prettier, Black, gofmt). Consistency is key.
- Prefer multi-line over long one-liners or complex ternaries for readability.
- Wrap long lines and do not reformat unrelated code in a change that is focused on logic.

## Types (for statically typed languages)
- Explicitly annotate public APIs and function signatures.
- Avoid unsafe casts or overly broad types (e.g., `any`, `Object`). Be as specific as possible.

## Change Discipline
- Perform changes via file editing tools; avoid pasting large code blobs in reviews.
- Re-read target files before editing to ensure accurate context.
- After edits, run only fast, non-interactive validation on changed files:
  - If a linter is configured, run it on changed paths (e.g., `eslint --max-warnings=0 <changed-paths>`). Use `--fix` when safe to auto-fix.
  - If a type checker is used, run type-check only (e.g., `tsc --noEmit` or `mypy <changed-paths>`).
  - Do NOT run Prettier as part of validation (formatting is enforced separately by tooling/CI).
  - Do NOT run a full build or dev server (to avoid unnecessary time cost).
  - Attempt auto-fixes up to 3 times for linter issues before requesting help.
```

## From javascript.md

```1:28:docs/ai/project/template-convention/javascript.md
# JavaScript Conventions (Essential)

## Language
- Use ES Modules (`import`/`export`).
- Prefer `const` (default) and `let`; avoid `var`.
- Use strict equality `===`/`!==`.
- Prefer optional chaining `?.` and nullish coalescing `??` over `||` when `0/''/false` are valid values.

## Syntax & Readability
- Use destructuring to access properties from objects and arrays.
- Use the spread syntax (`...`) for creating shallow copies of arrays and objects.
- Prefer array methods (`.map`, `.filter`, `.reduce`) over `for` loops for data transformation.
- Use `for...of` for simple iterations over iterables.

## Functions & Data
- Keep functions small and single-purpose.
- Use arrow functions (`=>`) for callbacks and to preserve `this` context.
- Avoid mutations; prefer immutable updates for objects/arrays.
- Return early (guard clauses) to reduce nesting.

## Errors & Async
- Use `async/await`; avoid unhandled promises (no floating promises).
- Throw `Error` objects with clear messages; catch only to handle meaningfully.

## Style & Safety
- Avoid implicit globals; module scope only.
- Prefer explicit returns over side effects.
- Keep imports minimal and ordered (std/third-party/internal).
```

## From react.md

```1:25:docs/ai/project/template-convention/react.md
# React Conventions (Essential)

## Components
- Use PascalCase for component names; one component per file (primary export).
- Props are immutable; derive minimal state. Lift state up when shared.
- Use stable `key` for lists (not index) when order can change.

## Hooks
- Follow the Rules of Hooks (top-level, consistent order).
- Declare all hook dependencies explicitly; prefer stable callbacks with `useCallback` when passed to children.
- Memoize expensive computations with `useMemo` only when measured bottlenecks exist.

## State & Effects
- Keep state minimal and serializable; avoid duplicating derived data.
- Side effects belong in `useEffect` with correct deps; cleanup subscriptions/timers.

## Performance
- Avoid unnecessary re-renders: memo child components when props are stable.
- Prefer split code (lazy + Suspense) for large routes/widgets.

## Accessibility
- Use semantic elements first; include `aria-*` only when needed.
- Ensure interactive elements are keyboard-accessible and have discernible labels.
```

## From typescript.md

```1:25:docs/ai/project/template-convention/typescript.md
# TypeScript Conventions (Essential)

## Types & Interfaces
- Use `interface` for public APIs and object shapes, as they are easily extended.
- Use `type` for unions (`|`), intersections (`&`), tuples, or complex type aliases.

## Naming Conventions
- Use `PascalCase` for all type-level identifiers (Types, Interfaces, Classes, Enums, Generics).
- Use `camelCase` for all value-level identifiers (variables, functions, properties).
- Avoid the `I` prefix for interfaces (e.g., `User`, not `IUser`).
- Use the `private` keyword instead of an underscore (`_`) prefix for private members.

## Type Safety
- Avoid `any`. It disables type-checking and defeats the purpose of TypeScript.
- Prefer `unknown` over `any`. It is a type-safe alternative that forces type-checking before use.
- Use `readonly` for properties that should not be mutated after initialization to enforce immutability.
- Explicitly type all public function signatures to ensure a clear and stable API.

## Modules & Organization
- Always use ES Modules (`import`/`export`).
- Prefer named exports over `default` exports. They improve consistency and refactorability.
- Avoid `namespace`. ES Modules provide superior encapsulation and are the language standard.

## Documentation
- Use JSDoc (`/** ... */`) for all exported members (functions, classes, types). This provides context and enables rich editor tooltips.
```

# Auto-Discovered and Q&A-Aligned Rules

- Languages/frameworks: Next.js + TypeScript + Supabase (confirmed).
- Formatter/Linter: ESLint + Prettier (confirmed).
- Tests: prefer `__tests__/` directories; name as `*.test.ts(x)` or `*.spec.ts(x)`.
- Error handling: use exceptions with `try/catch` at boundaries; rethrow with context.
- Async: prefer `async/await`; avoid floating promises; centralize API error normalization.
- Naming: `camelCase` for values/functions, `PascalCase` for types/classes, `UPPER_SNAKE_CASE` for constants.
- Imports: group and order as Node built-ins → third-party → internal, with blank lines between groups.
- Module organization: TBD (awaiting user choice: by feature / by layer / mixed).
- Security: never expose Supabase service role key to clients; enforce RLS.

<!-- GENERATED: CODE_CONVENTIONS:END -->
